<!--
 * @Author: LittleQ
 * @Date: 2023-02-15 22:52:13
 * @LastEditTime: 2023-02-21 23:36:08
 * @LastEditors: LittleQ
 * @Description: vue笔记
 * @FilePath: \NoteBook\vue\01.md
-->

### 1. vue 的生命周期

beforeCreate => created =>beforeMount => Mounted =>beforeUpdate => updated =>beforeDestroy=> destroyed

### 2. 父子组件生命周期顺序

父 beforeCreate => 父 created => 父 beforeMount =>
子 beforeCreate => 子 created =>子 beforeMount =>
子 Mounted =>父 Mounted

子组件先挂载 然后到父组件,更新也类似
父 beforeUpdate =>子 beforeUpdate => 子 updated => 父 updated

销毁
父 beforeDestroy
=>子 beforeDestroy => 子 destroyed
=>父 destroyed

### 3. vue 双向绑定原理 todo

- (1) 通过 Object.defineProperty()来监听 data 的属性。递归遍历，给每个对象和对象属性都设置成 observer
- (2) 通过发布订阅模式来双向驱动更新
- (3) compile 解析模板指令，如果有 text 类型的节点，判断是否有表达式，有的话添加到 Watcher 订阅者里面去，并且解析表达式
- (4) M=>V, 解析表达式，获取到 observer 监听的对象。判断是否添加到发消息的列表集合中去，返回值。
- (5) V=>M, 监听 dom 节点，将 dom 的值更新 observer 监听的对象中去，发布通知，订阅者 Watcher 调用 update()

### 4. vue2 的一些原理 todo

// todo

nextTick、diff、虚拟 dom、watch、computed、data 使用 return

- (1) nextTick 的作用

```js
new Vue({
  // ...
  methods: {
    // ...
    example: function () {
      // 修改数据
      this.message = "changed";
      // DOM 还没有更新
      this.$nextTick(function () {
        // DOM 现在更新了
        // `this` 绑定到当前实例
        this.doSomethingElse();
      });
    },
  },
});
```

- (2) vue 的虚拟 dom (vnode)
  作用：提升更新 dom 的效率，vnode 实际上是通过对象的方式来一一对应记录对应的 dom 元素。每次 dom 的更改，通过找到相应对象，也就找到了相应的 dom 节点，再对其进行更新。这样就能节省性能，因为 js 对象的查询，比对整个 dom 树的查询，所消耗的性能要少。
- (3) h 函数
  ```
  // 形态① h('div', {}, '文字')
  // 形态② h('div', {}, [])
  // 形态③ h('div', {}, h())
  ```
  作用：通过 h 函数，创建 vnode 虚拟 dom。
- (3) vue 中的 diff 算法

  作用：通过 diff 算法，找出新旧 vnode 的差异，因为 vnode 是和真实 dom 是一一对应的，因此找到需要更新的 vnode 节点，就可以更新局部 dom。提高渲染效率，提升性能。

  步骤：

  1. 调用 h 函数创建 vnode，并通过 patch 函数比较,将初始 vnode 更新到 root 根节点上去，渲染成 dom
  2. 当状态改变时：先调用 h 函数，创建新的 vnode 虚拟节点,调用 patch 函数，比较旧 vnode 和新 vnode
  3. patch(oldVnode, newVnode) 函数，通过 key (key 是提升 diff 算法效率的一个优化策略)会判断是不是同一个节点：

     - (1) 同一个节点：会调用 patchVnode(oldVnode, newVnode)进行同一个节点的遍历比较

       - (a) 判断 newVnode.text，有的话，直接替换掉 oldVnode 的 dom 的 innerText
         ```js
         {
           // 直接赋值，就完成dom更新了
           oldVnode.elm.innerText = newVnode.text;
         }
         ```
       - (b) newVnode 没有 text，必然就有 children 属性（vnode 定义）。newVnode.children  
         此时需要判断 oldVnode,是否*有无 children* 属性：

         1. 有：**此时是最复杂的情况**

            ```js
            // 老的有children，新的也有children，此时就是最复杂的情况。
            updateChildren(oldVnode.elm, oldVnode.children, newVnode.children);
            ```

            **diff 算法核心**

            ```js
            // 旧前
            let oldStartIdx = 0;
            // 新前
            let newStartIdx = 0;
            // 旧后
            let oldEndIdx = oldCh.length - 1;
            // 新后
            let newEndIdx = newCh.length - 1;
            // 旧前节点
            let oldStartVnode = oldCh[0];
            // 旧后节点
            let oldEndVnode = oldCh[oldEndIdx];
            // 新前节点
            let newStartVnode = newCh[0];
            // 新后节点
            let newEndVnode = newCh[newEndIdx];

            while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {}
            ```

            - a. ① 新前和旧前命中
              ```js
              patchVnode(oldStartVnode, newStartVnode);
              oldStartVnode = oldCh[++oldStartIdx];
              newStartVnode = newCh[++newStartIdx];
              ```
            - b. ② 新后和旧后命中
              ```js
              patchVnode(oldEndVnode, newEndVnode);
              oldEndVnode = oldCh[--oldEndIdx];
              newEndVnode = newCh[--newEndIdx];
              ```
            - c. ③ 新后和旧前命中
              ```js
              patchVnode(oldStartVnode, newEndVnode);
              // 当③新后与旧前命中的时候，此时要移动节点。移动新前指向的这个节点到老节点的旧后的后面
              parentElm.insertBefore(
                oldStartVnode.elm,
                oldEndVnode.elm.nextSibling
              );
              oldStartVnode = oldCh[++oldStartIdx];
              newEndVnode = newCh[--newEndIdx];
              ```
            - d. ④ 新前和旧后命中
              ```js
              patchVnode(oldEndVnode, newStartVnode);
              // 当④新前和旧后命中的时候，此时要移动节点。移动新前指向的这个节点到老节点的旧前的前面
              parentElm.insertBefore(oldEndVnode.elm, oldStartVnode.elm);
              oldEndVnode = oldCh[--oldEndIdx];
              newStartVnode = newCh[++newStartIdx];
              ```
            - e. 无命中：**todo**

         2. 无：直接清空 oldVnode.elm.innerHTML = '';并遍历 newVnode.children，创建 dom，添加到 oldVnode.elm 子元素中去。

     - (2) 不是同一个节点：通过调用 createElement(vnode)方法，递归调用，将 vnode 转成真实 dom,插入到 oldVnode.ele 的 dom 的父节点中去。

- (4) watch 和 computed 使用

### 5.vuex 的原理 todo

// todo

### 6. vueRoute 的原理

### 7. axios 的原理
